-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generics-based implementations for common typeclasses
--   
--   Provides generics-based implementations for common typeclasses using
--   Generics.
--   
--   Please see the README on Github at
--   <a>https://github.com/mstksg/one-liner-instances#readme</a>
@package one-liner-instances
@version 0.1.2.0


-- | Derived methods for <a>Bounded</a>, using <a>Generics.OneLiner</a> and
--   <a>GHC.Generics</a>.
--   
--   Can be used for any types (deriving <a>Generic</a>) where every field
--   is an instance of <a>Bounded</a>.
--   
--   Also includes a newtype wrapper that imbues any such data type with an
--   instant <a>Bounded</a> instance, which can one day be used with
--   <i>DerivingVia</i> syntax to derive instances automatically.
module Data.Bounded.OneLiner

-- | If <tt>a</tt> is a data type whose fields are all instances of
--   <a>Bounded</a>, then <tt><a>GBounded</a> a</tt> has a <a>Bounded</a>
--   instance.
--   
--   Will one day be able to be used with <i>DerivingVia</i> syntax, to
--   derive instances automatically.
newtype GBounded a
GBounded :: a -> GBounded a
[getGBounded] :: GBounded a -> a

-- | <a>minBound</a> implemented by using <a>minBound</a> for all of the
--   components for the first constructor
gMinBound :: forall a. (ADT a, Constraints a Bounded) => a

-- | <a>maxBound</a> implemented by using <a>maxBound</a> for all of the
--   components for the last constructor
gMaxBound :: forall a. (ADT a, Constraints a Bounded) => a
instance Data.Traversable.Traversable Data.Bounded.OneLiner.GBounded
instance Data.Foldable.Foldable Data.Bounded.OneLiner.GBounded
instance GHC.Base.Functor Data.Bounded.OneLiner.GBounded
instance GHC.Generics.Generic (Data.Bounded.OneLiner.GBounded a)
instance Data.Data.Data a => Data.Data.Data (Data.Bounded.OneLiner.GBounded a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Bounded.OneLiner.GBounded a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Bounded.OneLiner.GBounded a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Bounded.OneLiner.GBounded a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bounded.OneLiner.GBounded a)
instance (Generics.OneLiner.Internal.ADT a, Generics.OneLiner.Internal.Constraints a GHC.Enum.Bounded) => GHC.Enum.Bounded (Data.Bounded.OneLiner.GBounded a)


-- | Derived methods for <a>Semigroup</a> and <a>Monoid</a>, using
--   <a>Generics.OneLiner</a> and <a>GHC.Generics</a>.
--   
--   Can be used for any types (deriving <a>Generic</a>) made with a single
--   constructor, where every field is an instance of <a>Semigroup</a> (or
--   <a>Monoid</a>, depending on the function).
--   
--   Also includes a newtype wrapper that imbues any such data type with
--   instant <a>Semigroup</a> and <a>Monoid</a> instances, which can one
--   day be used with <i>DerivingVia</i> syntax to derive instances
--   automatically.
module Data.Monoid.OneLiner

-- | If <tt>a</tt> is a data type with a single constructor whose fields
--   are all instances of <a>Semigroup</a>, then <tt><a>GMonoid</a> a</tt>
--   has a <a>Semigroup</a> instance.
--   
--   If <tt>a</tt> is a data type with a single constructor whose fields
--   are all instances of <a>Monoid</a>, then <tt><a>GMonoid</a> a</tt> has
--   a <a>Monoid</a> instance.
--   
--   Will one day be able to be used with <i>DerivingVia</i> syntax, to
--   derive instances automatically.
newtype GMonoid a
GMonoid :: a -> GMonoid a
[getGMonoid] :: GMonoid a -> a

-- | Semigroup append (<a>&lt;&gt;</a>) implemented by calling
--   <a>&lt;&gt;</a> on the components.
gSemigroup :: forall a. (ADTRecord a, Constraints a Semigroup) => a -> a -> a

-- | Monoid append (<a>mappend</a>) implemented by calling <a>&lt;&gt;</a>
--   on the components.
gMappend :: forall a. (ADTRecord a, Constraints a Monoid) => a -> a -> a

-- | Monoid identity (<a>mempty</a>) implemented by using <a>mempty</a> for
--   all of the components.
gMempty :: forall a. (ADTRecord a, Constraints a Monoid) => a
instance Data.Traversable.Traversable Data.Monoid.OneLiner.GMonoid
instance Data.Foldable.Foldable Data.Monoid.OneLiner.GMonoid
instance GHC.Base.Functor Data.Monoid.OneLiner.GMonoid
instance GHC.Generics.Generic (Data.Monoid.OneLiner.GMonoid a)
instance Data.Data.Data a => Data.Data.Data (Data.Monoid.OneLiner.GMonoid a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Monoid.OneLiner.GMonoid a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Monoid.OneLiner.GMonoid a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.OneLiner.GMonoid a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.OneLiner.GMonoid a)
instance (Generics.OneLiner.Internal.ADTRecord a, Generics.OneLiner.Internal.Constraints a Data.Semigroup.Semigroup) => Data.Semigroup.Semigroup (Data.Monoid.OneLiner.GMonoid a)
instance (Generics.OneLiner.Internal.ADTRecord a, Generics.OneLiner.Internal.Constraints a Data.Semigroup.Semigroup, Generics.OneLiner.Internal.Constraints a GHC.Base.Monoid) => GHC.Base.Monoid (Data.Monoid.OneLiner.GMonoid a)


-- | Derived methods for <a>Eq</a> and <a>Ord</a>, using
--   <a>Generics.OneLiner</a> and <a>GHC.Generics</a>.
--   
--   Can be used for any types (deriving <a>Generic</a>) where every field
--   is an instance of <a>Eq</a> (or <a>Ord</a>).
--   
--   Also includes a newtype wrapper that imbues any such data type with
--   instant <a>Eq</a> and <a>Ord</a> instances, which can one day be used
--   with <i>DerivingVia</i> syntax to derive instances automatically.
module Data.Ord.OneLiner

-- | If <tt>a</tt> is a data type whose fields are all instances of
--   <a>Eq</a>, then <tt><a>GOrd</a> a</tt> has a <a>Eq</a> instance.
--   
--   If <tt>a</tt> is a data type whose fields are all instances of
--   <a>Ord</a>, then <tt><a>GOrd</a> a</tt> has a <a>Ord</a> instance.
--   
--   Will one day be able to be used with <i>DerivingVia</i> syntax, to
--   derive instances automatically.
newtype GOrd a
GOrd :: a -> GOrd a
[getGOrd] :: GOrd a -> a

-- | <a>==</a> implemented by using <a>==</a> between all of the
--   components, lexicographically. First compares constructors.
gEquals :: forall a. (ADT a, Constraints a Eq) => a -> a -> Bool

-- | <a>/=</a> implemented by using <a>/=</a> between all of the
--   components, lexicographically. First compares constructors.
gNotEquals :: forall a. (ADT a, Constraints a Eq) => a -> a -> Bool

-- | <a>compare</a> implemented by using <a>compare</a> between all of the
--   components, lexicographically. First compares constructors.
gCompare :: forall a. (ADT a, Constraints a Ord) => a -> a -> Ordering

-- | <a>&lt;=</a> implemented by using <a>&lt;=</a> between all of the
--   components. First compares constructors.
gLTE :: forall a. (ADT a, Constraints a Ord) => a -> a -> Bool

-- | <a>&lt;</a> implemented by using <a>&lt;</a> between all of the
--   components. First compares constructors.
gLT :: forall a. (ADT a, Constraints a Ord) => a -> a -> Bool

-- | <a>&gt;=</a> implemented by using <a>&gt;=</a> between all of the
--   components. First compares constructors.
gGTE :: forall a. (ADT a, Constraints a Ord) => a -> a -> Bool

-- | <a>&gt;</a> implemented by using <a>&gt;</a> between all of the
--   components. First compares constructors.
gGT :: forall a. (ADT a, Constraints a Ord) => a -> a -> Bool

-- | <a>max</a> implemented by using <a>max</a> between all of the
--   components. First compares constructors. If two items are equal,
--   returns the second.
gMax :: forall a. (ADT a, Constraints a Ord) => a -> a -> a

-- | <a>min</a> implemented by using <a>min</a> between all of the
--   components. First compares constructors. If two items are equal,
--   returns the first.
gMin :: forall a. (ADT a, Constraints a Ord) => a -> a -> a
instance Data.Traversable.Traversable Data.Ord.OneLiner.GOrd
instance Data.Foldable.Foldable Data.Ord.OneLiner.GOrd
instance GHC.Base.Functor Data.Ord.OneLiner.GOrd
instance GHC.Generics.Generic (Data.Ord.OneLiner.GOrd a)
instance Data.Data.Data a => Data.Data.Data (Data.Ord.OneLiner.GOrd a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Ord.OneLiner.GOrd a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Ord.OneLiner.GOrd a)
instance (Generics.OneLiner.Internal.ADT a, Generics.OneLiner.Internal.Constraints a GHC.Classes.Eq) => GHC.Classes.Eq (Data.Ord.OneLiner.GOrd a)
instance (Generics.OneLiner.Internal.ADT a, Generics.OneLiner.Internal.Constraints a GHC.Classes.Eq, Generics.OneLiner.Internal.Constraints a GHC.Classes.Ord) => GHC.Classes.Ord (Data.Ord.OneLiner.GOrd a)


-- | Derived methods for numeric typeclasses, using
--   <a>Generics.OneLiner</a> and <a>GHC.Generics</a>.
--   
--   Can be used for any types (deriving <a>Generic</a>) made with a single
--   constructor, where every field is an instance of <a>Num</a> (or
--   <a>Fractional</a> or <a>Floating</a>, depending on the function).
--   
--   Also includes a newtype wrapper that imbues any such data type with an
--   instant <a>Num</a> (and <a>Fractional</a> and <a>Floating</a>)
--   instance, which can one day be used with <i>DerivingVia</i> syntax to
--   derive instances automatically.
module Numeric.OneLiner

-- | If <tt>a</tt> is a data type with a single constructor whose fields
--   are all instances of <a>Num</a>, then <tt><a>GNum</a> a</tt> has a
--   <a>Num</a> instance.
--   
--   If <tt>a</tt> is a data type with a single constructor whose fields
--   are all instances of <a>Fractional</a>, then <tt><a>GNum</a> a</tt>
--   has a <a>Fractional</a> instance.
--   
--   If <tt>a</tt> is a data type with a single constructor whose fields
--   are all instances of <a>Floating</a>, then <tt><a>GNum</a> a</tt> has
--   a <a>Floating</a> instance.
--   
--   Will one day be able to be used with <i>DerivingVia</i> syntax, to
--   derive instances automatically.
newtype GNum a
GNum :: a -> GNum a
[getGNum] :: GNum a -> a
gPlus :: forall a. (ADTRecord a, Constraints a Num) => a -> a -> a
gMinus :: forall a. (ADTRecord a, Constraints a Num) => a -> a -> a
gTimes :: forall a. (ADTRecord a, Constraints a Num) => a -> a -> a
gNegate :: forall a. (ADTRecord a, Constraints a Num) => a -> a
gAbs :: forall a. (ADTRecord a, Constraints a Num) => a -> a
gSignum :: forall a. (ADTRecord a, Constraints a Num) => a -> a
gFromInteger :: forall a. (ADTRecord a, Constraints a Num) => Integer -> a
gDivide :: forall a. (ADTRecord a, Constraints a Fractional) => a -> a -> a
gRecip :: forall a. (ADTRecord a, Constraints a Fractional) => a -> a
gFromRational :: forall a. (ADTRecord a, Constraints a Fractional) => Rational -> a
gPi :: forall a. (ADTRecord a, Constraints a Floating) => a
gExp :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gLog :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gSqrt :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gPower :: forall a. (ADTRecord a, Constraints a Floating) => a -> a -> a
gLogBase :: forall a. (ADTRecord a, Constraints a Floating) => a -> a -> a
gSin :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gCos :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gTan :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gAsin :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gAcos :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gAtan :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gSinh :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gCosh :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gTanh :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gAsinh :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gAcosh :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
gAtanh :: forall a. (ADTRecord a, Constraints a Floating) => a -> a
instance Data.Traversable.Traversable Numeric.OneLiner.GNum
instance Data.Foldable.Foldable Numeric.OneLiner.GNum
instance GHC.Base.Functor Numeric.OneLiner.GNum
instance GHC.Generics.Generic (Numeric.OneLiner.GNum a)
instance Data.Data.Data a => Data.Data.Data (Numeric.OneLiner.GNum a)
instance GHC.Read.Read a => GHC.Read.Read (Numeric.OneLiner.GNum a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.OneLiner.GNum a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Numeric.OneLiner.GNum a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.OneLiner.GNum a)
instance (Generics.OneLiner.Internal.ADTRecord a, Generics.OneLiner.Internal.Constraints a GHC.Num.Num) => GHC.Num.Num (Numeric.OneLiner.GNum a)
instance (Generics.OneLiner.Internal.ADTRecord a, Generics.OneLiner.Internal.Constraints a GHC.Num.Num, Generics.OneLiner.Internal.Constraints a GHC.Real.Fractional) => GHC.Real.Fractional (Numeric.OneLiner.GNum a)
instance (Generics.OneLiner.Internal.ADTRecord a, Generics.OneLiner.Internal.Constraints a GHC.Num.Num, Generics.OneLiner.Internal.Constraints a GHC.Real.Fractional, Generics.OneLiner.Internal.Constraints a GHC.Float.Floating) => GHC.Float.Floating (Numeric.OneLiner.GNum a)
